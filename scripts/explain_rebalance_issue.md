# rebalance_interval 변경 시 지표가 동일한 이유

## 핵심 발견

### 1. 입력 데이터의 특성
- `rebalance_scores` 데이터가 **월별로만 존재**합니다 (평균 30일 간격, 총 105개 날짜)
- 이는 L6R 단계에서 이미 날짜가 필터링된 상태입니다

### 2. rebalance_interval 필터링의 실제 효과

**BT20 모델 (입력: 105개 날짜, 월별)**:
- `rebalance_interval=1`: 105개 날짜 모두 사용 → 105개 리밸런싱
- `rebalance_interval=20`: 매 20번째 날짜만 사용 → **6개 리밸런싱** (예상)
- **실제 결과**: 105개 리밸런싱 (모든 날짜 사용)

**BT120 모델 (입력: 105개 날짜, 월별)**:
- `rebalance_interval=6`: 매 6번째 날짜만 사용 → **17개 리밸런싱** (예상)
- `rebalance_interval=120`: 매 120번째 날짜만 사용 → **1개 리밸런싱** (예상)
- **실제 결과**: 17개 리밸런싱

### 3. 지표가 동일한 이유

**가능한 원인**:

1. **입력 데이터가 이미 sparse함**
   - 월별 데이터만 존재하므로, `rebalance_interval`을 변경해도 실제 리밸런싱 날짜가 크게 변하지 않을 수 있습니다
   - 예: `rebalance_interval=1`과 `rebalance_interval=20`의 차이가 105개 → 6개로 줄어야 하는데, 입력 데이터가 월별이므로 실제로는 모든 날짜를 사용하게 됩니다

2. **Forward return의 특성**
   - `true_short`는 리밸런싱 날짜로부터 20일 후의 수익률입니다
   - 리밸런싱 날짜가 달라도, forward return이 겹치는 구간이 있을 수 있습니다
   - 하지만 이것도 누적 수익률은 달라야 합니다

3. **코드 버그 가능성**
   - `rebalance_interval` 필터링이 제대로 작동하지 않을 수 있습니다
   - 또는 입력 데이터가 이미 필터링된 상태일 수 있습니다

## 해결 방법

1. **입력 데이터의 날짜 분포 확인**: `rebalance_scores` 데이터가 실제로 어떤 날짜에 존재하는지 확인
2. **rebalance_interval 필터링 로직 검증**: 코드에서 필터링이 제대로 작동하는지 확인
3. **실제 리밸런싱 날짜 수 비교**: `rebalance_interval` 변경 전후의 리밸런싱 날짜 수를 비교

## 결론

**입력 데이터가 월별로만 존재**하므로, `rebalance_interval`을 변경해도 실제 리밸런싱 날짜가 크게 변하지 않을 수 있습니다.

예를 들어:
- `rebalance_interval=1`: 105개 날짜 모두 사용
- `rebalance_interval=20`: 6개 날짜만 사용해야 하지만, 입력 데이터가 월별이므로 실제로는 모든 날짜를 사용하게 됩니다

이것이 지표가 동일한 이유일 수 있습니다.

